<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Сборка</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Установим шрифт Inter по умолчанию */
        body {
            font-family: 'Inter', sans-serif;
        }
        
        /* Пользовательский цвет для фона карточки задачи (Возврат к #1A1A1A) */
        .task-card-bg {
            background-color: #1A1A1A; 
        }

        /* Фон таймера: Нормальное состояние (Темно-синий, #000033) */
        .timer-bg-default {
            background-color: #000033;
            color: #0000FF; /* Яркий синий цвет для текста таймера */
        }
        
        /* Фон таймера: Менее 60 секунд (Оранжевый) */
        .timer-bg-warning {
            background-color: #F97316; /* Tailwind orange-600 */
            color: #1A1A1A; /* Темный текст для контраста */
        }

        /* Фон таймера: Просрочен (Темно-красный фон, Красный текст) */
        .timer-bg-negative {
            background-color: #4D0A0A; /* Красный с 20% яркостью */
            color: #DC2626; /* Яркий красный цвет для текста */
        }

        /* Дополнительный класс, чтобы заголовок не закрывал контент при скролле */
        .sticky-header-spacing {
            padding-top: 4.5rem; /* Добавляем отступ, равный высоте закрепленного заголовка */
        }
    </style>
</head>
<body class="bg-[#0F0F0F] text-white">

    <div class="px-4 pt-3 pb-8 flex flex-col min-h-screen"> 

        <header class="sticky top-0 z-10 w-full mb-4 pt-1 pb-3 bg-[#0F0F0F] shadow-lg">
            
            <div class="relative flex items-center justify-center">
                <a href="#" class="absolute left-0 text-gray-400 hover:text-white transition duration-200 p-1 rounded-lg">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2.5" stroke="currentColor" class="w-5 h-5">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M10.5 19.5L3 12m0 0l7.5-7.5M3 12h18" />
                    </svg>
                </a>
    
                <h1 class="text-base font-bold text-center">
                    Сборка
                </h1>
            </div>
        </header>

        <main class="flex-grow flex flex-col">
            
            <div id="task-counter" class="text-white text-xl font-bold mb-4 flex-shrink-0 hidden">
                Ожидают 0
            </div>

            <div id="tasks-container" class="space-y-3 flex-shrink-0 hidden">
                </div>

            <div id="empty-state" class="flex flex-col items-center justify-center flex-grow text-center">
                <svg class="w-24 h-24 text-gray-700 mb-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M3 7v10a2 2 0 002 2h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2zM3 7h18" />
                </svg>
                <p class="text-gray-500 text-xl font-medium">Ждём новые задачи</p>
                <p id="error-message" class="text-red-500 text-sm mt-4 hidden">Не удалось загрузить задачи.</p>
            </div>
            
        </main>

    </div>

    <script>
        // --- 1. Настройка API ---
        const SERVER_URL = 'https://script.google.com/macros/s/AKfycbyaZSgumwWmcbL4L2IHjWVgmHjUEb8cudqhrJqb5F7w2cdyfSBRRUaly1JrCrteoYDy/exec'; // <-- ЗАМЕНИТЬ НА ВАШ URL!
        
        // --- 2. Инициализация DOM-элементов ---
        const tasksContainer = document.getElementById('tasks-container');
        const taskCounter = document.getElementById('task-counter');
        const emptyState = document.getElementById('empty-state');
        const errorMessage = document.getElementById('error-message');
        
        // Глобальный массив для хранения состояния задач, полученного с сервера
        let tasks = []; 
        let lastSuccessfulFetchTime = 0;

        /**
         * Форматирует общее количество секунд в строку MM:SS.
         */
        function formatTime(totalSeconds) {
            const absSeconds = Math.abs(totalSeconds);
            const minutes = Math.floor(absSeconds / 60);
            const seconds = absSeconds % 60;
            
            const formattedMinutes = String(minutes).padStart(2, '0');
            const formattedSeconds = String(seconds).padStart(2, '0');
            
            return `${formattedMinutes}:${formattedSeconds}`;
        }

        /**
         * Создает HTML-элемент карточки задачи на основе данных с сервера.
         * @param {object} task Объект задачи с id и durationSeconds.
         */
        function createTaskElement(task) {
            const taskCard = document.createElement('button');
            taskCard.className = 'w-full flex flex-col p-3 task-card-bg rounded-md shadow-lg hover:ring-2 hover:ring-blue-500 transition duration-150 text-left relative';
            taskCard.id = `task-${task.id}`; 

            // Вставляем пустые элементы, которые будут обновлены функцией renderTaskDisplay
            taskCard.innerHTML = `
                <div class="flex items-center justify-between w-full">
                    <span class="font-semibold text-sm text-gray-200">
                        ${task.id}
                    </span>
                    
                    <span class="timer-display text-xs font-semibold px-3 py-1 rounded-md">
                        --:--
                    </span>
                </div>
                <div class="status-message mt-2 hidden">
                    <span class="flex items-center text-red-500 text-xs font-medium">
                        <svg xmlns="http://www.w3.org/2000/svg" class="w-3 h-3 mr-1" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <circle cx="12" cy="12" r="10"></circle>
                            <polyline points="12 6 12 12 16 14"></polyline>
                        </svg>
                        Поторопись с задачей
                    </span>
                </div>
            `;
            return taskCard;
        }

        /**
         * Применяет стили и текст таймера к HTML-элементу задачи.
         * @param {HTMLElement} element Элемент карточки задачи.
         * @param {number} totalSeconds Оставшееся время в секундах.
         */
        function updateTaskDisplay(element, totalSeconds) {
            const timerDisplay = element.querySelector('.timer-display');
            const statusMessage = element.querySelector('.status-message');
            
            if (!timerDisplay || !statusMessage) return; 
            
            // 1. Сброс классов
            timerDisplay.classList.remove('timer-bg-default', 'timer-bg-warning', 'timer-bg-negative');
            
            let displayString = formatTime(totalSeconds);

            // 2. Управление видимостью сообщения
            if (totalSeconds <= 60) {
                statusMessage.classList.remove('hidden');
            } else {
                statusMessage.classList.add('hidden');
            }

            // 3. Управление стилями
            if (totalSeconds < 0) {
                // C. Просрочка
                timerDisplay.classList.add('timer-bg-negative');
                displayString = '+' + displayString; 
            } else if (totalSeconds <= 60) {
                // B. Предупреждение
                timerDisplay.classList.add('timer-bg-warning');
            } else {
                // A. Нормальное состояние
                timerDisplay.classList.add('timer-bg-default');
            }
            
            timerDisplay.textContent = displayString;
        }

        /**
         * Перерисовывает элементы DOM в соответствии с текущим массивом задач.
         */
        function redrawTasks() {
            // Удаляем все текущие элементы из контейнера
            tasksContainer.innerHTML = '';
            
            // Создаем и добавляем элементы в DOM
            tasks.forEach(task => {
                const element = createTaskElement(task);
                tasksContainer.appendChild(element);
                task.element = element; // Сохраняем ссылку на элемент для быстрого доступа
            });

            // Обновляем счетчик и видимость UI
            updateTaskCounter();
        }

        /**
         * Обновляет счетчик задач и управляет видимостью состояний UI.
         */
        function updateTaskCounter() {
            const count = tasks.length;
            if (count > 0) {
                taskCounter.textContent = `Ожидают ${count}`; 
                taskCounter.classList.remove('hidden');
                tasksContainer.classList.remove('hidden');
                emptyState.classList.add('hidden');
            } else {
                taskCounter.classList.add('hidden');
                tasksContainer.classList.add('hidden');
                emptyState.classList.remove('hidden');
            }
        }
        
        /**
         * Обновляет все таймеры каждую секунду, используя локальное смещение времени
         * на основе данных, полученных с сервера.
         */
        function updateTimersDisplay() {
            const currentTime = new Date().getTime();
            
            tasks.forEach(task => {
                // Рассчитываем, сколько секунд прошло с момента последнего успешного запроса
                const timeElapsedSeconds = Math.round((currentTime - lastSuccessfulFetchTime) / 1000);

                // Оставшееся время = (Время с сервера) - (Время, прошедшее с запроса)
                const currentDuration = task.durationSeconds - timeElapsedSeconds;
                
                if (task.element) {
                    updateTaskDisplay(task.element, currentDuration);
                }
            });

            // После обновления таймеров, мы не пересортировываем, чтобы сохранить плавность.
            // Пересортировка и перерисовка будет происходить только при fetchTasksFromServer.
        }

        /**
         * Запрашивает актуальный список задач у сервера Google App Script.
         */
        async function fetchTasksFromServer() {
            try {
                const response = await fetch(`${SERVER_URL}?action=getTasks`);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const serverTasks = await response.json();
                
                // 1. Обновляем глобальное состояние
                tasks = serverTasks;

                // 2. Сохраняем время успешного получения
                lastSuccessfulFetchTime = new Date().getTime(); 
                
                // 3. Полностью перерисовываем список (это также обновляет счетчик)
                redrawTasks();
                
                errorMessage.classList.add('hidden');
                console.log(`[Клиент] Задачи успешно загружены. Всего: ${tasks.length}`);

            } catch (error) {
                console.error("Ошибка при запросе задач с сервера:", error);
                // Показываем сообщение об ошибке, но не очищаем список
                errorMessage.classList.remove('hidden'); 
            }
        }

        // Инициализация:
        window.onload = function() {
            // 1. Запускаем первый запрос немедленно
            fetchTasksFromServer(); 
            
            // 2. Запускаем регулярный запрос к серверу каждые 5 секунд.
            // Это обновит список и его сортировку на основе серверных данных.
            setInterval(fetchTasksFromServer, 5000); 

            // 3. Запускаем ежесекундный таймер для плавного отображения обратного отсчета
            // между серверными обновлениями (каждые 5 секунд).
            setInterval(updateTimersDisplay, 1000); 
            
            console.log("Клиентский скрипт запущен. Запрос к серверу каждые 5 секунд.");
        };

    </script>

</body>
</html>
